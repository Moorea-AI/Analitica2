# -*- coding: utf-8 -*-
"""CALCULO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SICWQbJLoyfbTeV2gjS6G5GlmFZzJNxl

[![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1SICWQbJLoyfbTeV2gjS6G5GlmFZzJNxl?usp=sharing)

#PROYECTO DE AULA<br>
##ANALITICA PARA LA TOMA DE DECISIONES

Por:

Lorena Giraldo<br>
Laura Herrera<br>
Aura Moreno<br>
Carlos Vásquez<br><br><br>

En este trabajo abordaremos:<br>
a. Limpieza y transformación de los datos<BR>
b. Análisis exploratorio de los datos.<BR>
c. Preparación de los datos y selección de variables.<BR>
d. Aplicación de algoritmo.<BR>
e. Evaluación y análisis del modelo base.<BR>

Descripcion de las variables

* **departamento**: carrera que cursa el estudiante (nominal: 'II' - Ingeniería Industrial/ IS' - Ingeniería de Sistemas)
* **sexo**: sexo del estudiante (nominal: 'M' - Mujer/'H' - Hombre)
* **edad**:	edad del estudiante (númerica: de 15 a 22)
* **direccion**: dirección del estudiante (nominal: 'U' - urbana/'R' - rural)
* **t_familia**: tamaño de la familia (nominal: 'menor_e3' - menor o igual a 3/'mayor_3' - más de 3)
* **padres_status**: estado de convivencia de los padres  (nominal: 'J' - viven juntos/'S' - separados)
* **madre_edu**: educación de la madre (numérica: 0 - ninguno/1 - educación primaria (hasta 5º)/2 - 6º a 9º/3 - 10º a 11º /4 - educación superior)
* **padre_edu**: educación del padre (numérica: 0 - ninguno/1 - educación primaria (hasta 5º)/2 - 6º a 9º/3 - 10º a 11º /4 - educación superior)
* **madre_trab**: trabajo de la madre (nominal: 'maestra'/'salud'/'servicios' civiles (por ejemplo, administrativo o policía)/'en_casa'/'otro')
* **padre_trab**: trabajo del padre (nominal: 'maestro'/'salud'/'servicios' civiles (por ejemplo, administrativo o policía)/'en_casa'/'otro')
* **razon**: razón para elegir la carrera (nominal: 'recomendacion'/'reputación'/'habilidad'/'otro')
* **guardian**: tutor del estudiante (nominal: 'madre'/'padre'/'otro')
* **t_examen**:	tiempo que demoro en realizar el primer examen (numérica: 1 - <15 min./2 - 15 a 30 min./3 - 30 min. a 1 hora/4 - >1 hora)
* **t_estudio**: tiempo de estudio semanal (numérica: 1 - <2 horas/2 - 2 a 5 horas/3 - 5 a 10 horas/4 - >10 horas)
* **faltas**: número de faltas a la clase (numérica: n si 1<=n<3, si no 4)
* **soporte_edu_extra**: apoyo educativo adicional (nominal: sí o no)
* **soporte_edu_fam**: apoyo educativo familiar (nominal: si o no)
* **monitores**: clases extra pagadas por tutores privados (nominal: sí o no)
* **actividades_extra**: actividades extraescolares (nominal: sí o no)
* **preuniversitario**: asistió al preuniversitario (nominal: sí o no)
* **postgrado**: quiere hacer postgrado (nominal: sí o no)
* **internet**: acceso a Internet en casa (nominal: sí o no)
* **relacion_sen**:	con una relación romántica (nominal: sí o no)
* **relacion_fam**:	calidad de las relaciones familiares (numérica: de 1 - muy mala a 5 - excelente)
* **tiempo_libre**: tiempo libre después de la universidad (numérica: de 1 - muy bajo a 5 - muy alto)
* **salir_amigos**:	salir con amigos (numérica: desde 1 - muy baja hasta 5 - muy alta)
* **cons_alcohol_sem**: consumo de alcohol en jornada laboral (numérica: de 1 - muy bajo a 5 - muy alto)
* **cons_alcohol_finde**: consumo de alcohol en fin de semana (numérica: de 1 - muy bajo a 5 - muy alto)
* **salud**: estado de salud actual (numérica: de 1 - muy malo a 5 - muy bueno)
* **ausencias**: número de ausencias a la universidad (numérica: de 0 a 93)
* **nota_01**: puntuación primer examen (numérica: de 0 a 20)
* **nota_02**: puntuación segundo examen (numérica: de 0 a 20)
* **nota_03**: puntuación tercer examen (numérica: de 0 a 20) - variable a predecir

# **Importación de liberías**
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.stats import norm
from sklearn.preprocessing import StandardScaler, LabelEncoder, MinMaxScaler
from scipy import stats
import warnings
from itertools import product

# Visualizaciones
from plotly.subplots import make_subplots
import plotly.subplots as sp
import plotly.graph_objects as go
import plotly.express as px
!pip install plot-metric

# %matplotlib inline

# modelos
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score,confusion_matrix, ConfusionMatrixDisplay, f1_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, MinMaxScaler
import joblib

"""# **Bases de datos**<br>
### Se hace llamado a las bases de datos de Algebra y Cálculo
"""

#llamado a las base de dato de Cálculo
CALCULO = pd.read_csv('https://www.4minds.solutions/Analitica2/calculo_diferencial.csv', sep=',',  low_memory=False) #Base de datos de Calculo Diferencial

#Revisamos internamente el contenido
CALCULO

"""# **Análisis a las base de datos de Cálculo**
#### Hacemos el análisis exploratorio de la  bases de datos.

#**CALCULO**

## Analisis exploratorio
"""

from IPython.display import display, Markdown
pd.set_option('display.max_columns', None)

def check_df(dataframe, head=10):
    display(Markdown('**Dimensiones base general**'))
    display(dataframe.shape)

    display(Markdown('**Dimensiones sin duplicados**'))
    display(dataframe.drop_duplicates().shape )

    display(Markdown('**Tipos**'))
    display(dataframe.dtypes)

    display(Markdown('**Primeros Registros**'))
    display(dataframe.head(head))

    display(Markdown('**Nulos**'))
    display(dataframe.isnull().sum())

    display(Markdown('**Percentiles**'))
    display(dataframe.describe([0, 0.05, 0.50, 0.95, 0.99, 1]).T)
check_df(CALCULO)

# Eliminar columna posición 0
CALCULO.drop(CALCULO.columns[0], axis=1, inplace=True)

"""Eliminamos esta columna porque es un indice de las filas y esto no aporta relevancia al modelo

No se observa presencia de nulos en la base de datos
"""

display(CALCULO[CALCULO.duplicated(keep='last')])
display(CALCULO[CALCULO.duplicated(keep='first')])

"""Observamos que hay 2 pares de duplicados en la BD
*   La fila 0 y la 395
*   La fila 383 y la 396

Se toma la decisión de dejar los duplicados, ya que se asume que son situaciones reales y que realmente 2 estudiantes pueden tener las mismas caracteristicas.

## Analisis univariado

### Variables categóricas
"""

CALCULO.describe(include='object').transpose()

"""De este *describe* de las variables categoricas, podemos observar que:
* Las variables *departamento, padres_status y postgrado*, tiene una categoria dominante con registros por encima de 350.
* Solo las variables *madre_trab, padre_trab, razon y guardian* tienen más de 2 categorías.
"""

# CALCULO
def cat_summary(dataframe, col_name, plot=False):
    print(pd.DataFrame({col_name: dataframe[col_name].value_counts(),
                        'Ratio': 100 * dataframe[col_name].value_counts() / len(dataframe)}))
    print('##########################################')
    if plot:
        plt.figure(figsize=(12,6))
        sns.countplot(x=dataframe[col_name], data=dataframe)
        plt.show(block=True)

cat_cols = [col for col in CALCULO.columns if CALCULO[col].dtypes == "O"]
for col in cat_cols:
    cat_summary(CALCULO, col, plot=False)

"""* En este codigo podemos observar en terminos porcentuales como es la distribucion de las categorias, y de acuerdo con estos porcentajes confirmamos que la dominancia de la categoria 'si' en la variable *postgrado* si es muy significativa, por lo cual es una variable que analizaremos que con mayor cuidado posteriormente, esto con el fin de tomar la decisión si la descartamos o no.
* Por otra parte, las variables *madre_trab y padre_trab* tienen categorías que se pueden reagrupar, porque su porcentaje respecto a las demás categorías es muy bajo

### Variables numericas
"""

CALCULO.describe().transpose()

"""Las estadísticas descriptivas revelan que, en promedio, los estudiantes tienen alrededor de 16.71 años de edad, con una baja variabilidad en este aspecto. La educación de los padres tiende a situarse en niveles intermedios, con una ligera ventaja en la educación de las madres. En cuanto al consumo de alcohol, se observa un consumo moderado tanto durante la semana como los fines de semana. Las notas académicas promedio se sitúan en torno a 10.88, 10.69 y 10.38 en tres evaluaciones respectivas, con una variabilidad notable. Por último, las ausencias presentan una amplia variabilidad, con un promedio de 5.70. Estas estadísticas ofrecen una visión panorámica de la población estudiantil, destacando aspectos clave como la edad, la educación parental, el consumo de alcohol, el rendimiento académico y la asistencia a clases.

## Análisis Univariado con gráficos

### Variable respuesta
"""

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO['nota_03'], name='Histograma de la nota 3', marker_color='coral'),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO['nota_03'], name='Boxplot de la nota 3', marker_color='coral'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de la nota 3",
    template='simple_white')
fig.show()

"""La variable respuesta tiene mucha variabilidad en los datos, un posible sesgo a la izquierda y no se observan datos atipicos, tambien esta desbalanceada

### Variables independientes

**1**. *Departamento*
"""

# Cambiar el nombre de la categoria MS por IS
CALCULO['departamento'] = CALCULO['departamento'].replace('MS', 'IS')
CALCULO['departamento'].value_counts()

# crear gráfica
fig = px.pie(CALCULO, names='departamento', title ='<b>Departamento<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Carrera',
    yaxis_title = 'Cantidad de estudiantes',
    legend_title = '<b>Carrera<b>',
    template = 'simple_white',
    title_x = 0.5)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Set3))

fig.show()

"""Se observa que para la variable departamento la categoría Ingeniería industrial tiene mucho peso y esto podría afectar el modelo, se va a revisar en el análisis bivariado para decidir si eliminar esta variable

2. *Sexo*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'sexo', title = '<b>Sexo<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
     title_x = 0.5
)
# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Plotly))

fig.show()

"""Se observa que ambas categorías se encuentran balanceadas y no parece que vaya a afectar negativamente el modelo.

3. *Edad*
"""

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO['edad'], name='Histograma de la edad', marker_color=px.colors.qualitative.Pastel1),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO['edad'], name='Boxplot de la edad', marker_color='purple'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de las edades",
    template='simple_white')
fig.show()

#Identificar atípicos
# Calcular el rango intercuartílico (IQR)
Q1 = CALCULO['edad'].quantile(0.25)
Q3 = CALCULO['edad'].quantile(0.75)
IQR = Q3 - Q1

# Calcular los límites para identificar valores atípicos
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Filtrar los valores atípicos
valores_atipicos = CALCULO[(CALCULO['edad'] < lower_bound) | (CALCULO['edad'] > upper_bound)]['edad']

# Obtener la cantidad de valores atípicos
print(f"Cantidad de valores atípicos: {len(valores_atipicos)}")

"""De acuerdo con este primer resultado podemos observar que las edades de 20, 21 y 22 años tienen 3 ó 1 registro, lo cual es imperceptible para el modelo, Se observa la presencia de un valor atípico.

Para tratar este comportamiento vamos a reagrupar estos datos con la edad 19.

##Agrupación de la variables "Edad"
"""

# Crear una copia del DataFrame para evitar modificar el original
CALCULO_nuevo = CALCULO.copy()

# Utilizar replace para modificar los valores en la nueva columna
CALCULO_nuevo['edad_agrup'] = CALCULO_nuevo['edad'].replace({22: 19, 21: 19, 20: 19})

# Ahora, CALCULO_nuevo contiene la variable 'edad_agrup' con la agrupación realizada

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO_nuevo['edad_agrup'], name='Histograma de la edad', marker_color=px.colors.qualitative.Pastel1[3]),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO_nuevo['edad_agrup'], name='Boxplot de la edad', marker_color='#d62728'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de las edades",
    template='simple_white')
fig.show()

"""Se observa nuevamente la gráfica y se nota que se encuentran mejor balanceadas las categorías

*4*. *Dirección*
"""

# crear gráfica
fig = px.pie(CALCULO, names='direccion', title ='<b>Dirección<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Direccion',
    yaxis_title = 'Cantidad de estudiantes',
    legend_title = '<b>Zona<b>',
    template = 'simple_white',
    title_x = 0.5)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel1))

fig.show()

"""Se observa que ambas categorías se encuentran balanceadas y no parece que vaya a afectar negativamente el modelo.

*5*. *Tamaño de la familia*
"""

# crear gráfica
fig = px.pie(CALCULO, names='t_familia', title ='<b>Tamaño de la familia<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Tamaño de la familia',
    yaxis_title = 'Proporciones',
    template = 'simple_white',
    title_x = 0.5)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""Se observa que ambas categorias se encuentran balanceadas y no parece que vaya a afectar negativamente el modelo.

6. *Estatus de los padres*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'padres_status', title = '<b>Estado de convivencia de los padres<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""Se observa que para la variable Status de los padres la categoría Juntos tiene mucho peso y esto podría afectar el modelo, se va a revisar en el análisis bivariado para decidir si eliminar o dejar esta variable.

7. *Educación de la madre*
8. *Educación del padre*
"""

CALCULO['count'] = 1

df1 = CALCULO.groupby('madre_edu')['count'].sum().reset_index()
df2 = CALCULO.groupby('padre_edu')['count'].sum().reset_index()

# Crear subplots
fig = make_subplots(rows=1, cols=2)

# Crear y agregar trazas de barras a los subplots
bar_trace1 = go.Bar(x=df1['madre_edu'], y=df1['count'], name='Madre', marker_color='lightblue')
bar_trace2 = go.Bar(x=df2['padre_edu'], y=df2['count'], name='Padre', marker_color='lightgreen')

fig.add_trace(bar_trace1, row=1, col=1)
fig.add_trace(bar_trace2, row=1, col=2)

# Actualizar el diseño de la figura
fig.update_layout(
    xaxis_title='Educación',
    yaxis_title='Cantidad',
    title_text='<b>Grado de educación de los padres<b>',
    title_x=0.5,
    template='simple_white'
)

# Mostrar la figura
fig.show()

"""Se observa un comportamiento similar de ambas variables, donde la categoría cero no tiene datos significativos, se decide reagrupar y quedaría de la siguiente manera:
agrupamos la 0 y la 1, la 2 y la 3, la 4 se deja igual.

1 no estudiaron o hasta quinto de primaria

2 los que cursaron hasta el grado 11

3 los que son profesionales
"""

# Utilizar replace para modificar los valores en la nueva variable
CALCULO_nuevo['madre_edu_agrup'] = CALCULO_nuevo['madre_edu'].replace({0: 1, 3: 2, 4: 3})

# Hacer lo mismo para la variable padre_edu
CALCULO_nuevo['padre_edu_agrup'] = CALCULO_nuevo['padre_edu'].replace({0: 1, 3: 2, 4: 3})

CALCULO_nuevo['count'] = 1
df1 = CALCULO_nuevo.groupby('madre_edu_agrup')['count'].sum().reset_index()
df2 = CALCULO_nuevo.groupby('padre_edu_agrup')['count'].sum().reset_index()

# Crear subplots
fig = make_subplots(rows=1, cols=2)

# Crear y agregar trazas de barras a los subplots
bar_trace1 = go.Bar(x=df1['madre_edu_agrup'], y=df1['count'], name='Madre', marker_color='lightblue')
bar_trace2 = go.Bar(x=df2['padre_edu_agrup'], y=df2['count'], name='Padre', marker_color='lightgreen')
fig.add_trace(bar_trace1, row=1, col=1)
fig.add_trace(bar_trace2, row=1, col=2)

# Actualizar el diseño de la figura
fig.update_layout(
    xaxis_title='Educación',
    yaxis_title='Cantidad',
    title_text='<b>Grado de educación de los padres<b>',
    title_x=0.5,
    template='simple_white'
)

# Mostrar la figura
fig.show()

"""Se observa nuevamente la gráfica y se nota que las categorías están mejor balanceadas

9. *Trabajo de la madre*
10. *Trabajo del padre*
"""

df1 = CALCULO.groupby('madre_trab')['count'].sum().reset_index()
df2 = CALCULO.groupby('padre_trab')['count'].sum().reset_index()

# Crear subplots
fig = make_subplots(rows=1, cols=2)

# Ordenar los DataFrames por 'count' de mayor a menor
df1 = df1.sort_values(by='count', ascending=False)
df2 = df2.sort_values(by='count', ascending=False)

# Crear y agregar trazas de barras a los subplots
bar_trace1 = go.Bar(x=df1['madre_trab'], y=df1['count'], name='Madre',marker_color='burlywood')
bar_trace2 = go.Bar(x=df2['padre_trab'], y=df2['count'], name='Padre',marker_color='lightblue')

fig.add_trace(bar_trace1, row=1, col=1)
fig.add_trace(bar_trace2, row=1, col=2)

# Actualizar el diseño de la figura
fig.update_layout(
    xaxis_title='Tipo de trabajo',
    yaxis_title='Cantidad',
    title_text='<b>Tipo de trabajo de los padres<b>',
    title_x=0.5,
    template='simple_white'
)

"""Se observa un comportamiento similar de ambas variables, se decide agrupar la categoría salud con la categoría otros, ya que porcentualmente es muy baja"""

# Hacer la agrupación de salud en una nueva variable para no modificar la original
CALCULO_nuevo['madre_trab_agrup'] = CALCULO_nuevo['madre_trab'].replace({'salud': 'otro'})
CALCULO_nuevo['padre_trab_agrup'] = CALCULO_nuevo['padre_trab'].replace({'salud': 'otro'})

df1 = CALCULO_nuevo.groupby('madre_trab_agrup')['count'].sum().reset_index()
df2 = CALCULO_nuevo.groupby('padre_trab_agrup')['count'].sum().reset_index()

# Crear subplots
fig = make_subplots(rows=1, cols=2)

# Ordenar los DataFrames por 'count' de mayor a menor
df1 = df1.sort_values(by='count', ascending=False)
df2 = df2.sort_values(by='count', ascending=False)

# Crear y agregar trazas de barras a los subplots
bar_trace1 = go.Bar(x=df1['madre_trab_agrup'], y=df1['count'], name='Madre',marker_color='lightseagreen')
bar_trace2 = go.Bar(x=df2['padre_trab_agrup'], y=df2['count'], name='Padre',marker_color='palegreen')

fig.add_trace(bar_trace1, row=1, col=1)
fig.add_trace(bar_trace2, row=1, col=2)

# Actualizar el diseño de la figura
fig.update_layout(
    xaxis_title='Tipo de trabajo',
    yaxis_title='Cantidad',
    title_text='<b>Tipo de trabajo de los padres<b>',
    title_x=0.5,
    template='simple_white'
)

"""Se observan nuevamente las gráficas y se nota que las categorías están un poco mejor balanceadas

11. *Razón*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'razon', title = '<b>Razón por la cual eligio la carrera<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""Se observa un comportamiento balanceado de todas las categorías.

12. *Guardian*
"""

# crear gráfica
fig = px.pie(CALCULO, names='guardian', title ='<b>Tutor del estudiante<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Tutor',
    yaxis_title = 'Proporciones',
    template = 'simple_white',
    title_x = 0.5)
# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""Se observa que la mayoría de estudiantes tienen como tutor a la madre, tiene un comportamiento similar a la realidad, pero para el modelo es una variable que se debe analizar con más detalle en el análisis bivariado.

13. *Tiempo examen*
"""

# Crear gráfica de barras
fig = px.histogram(CALCULO, x='t_examen', title='<b>Tiempo que se demoró en el primer examen<b>')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Tiempo',
    yaxis_title='Cantidad de estudiantes',
    template='simple_white',
    title_x=0.5)

# Personaliza los colores de los segmentos
fig.update_traces(marker_color=px.colors.qualitative.Pastel1)

fig.show()

"""Se observa que las categorías 3 y 4 no tienen datos muy significativos, se considerará más detalladamente en el análisis bivariado.

14. *Tiempo estudio*
"""

# Crear gráfica de barras
fig = px.histogram(CALCULO, x='t_estudio', title='<b>Tiempo semanal que dedicó a estudiar<b>')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Tiempo',
    yaxis_title='Cantidad de estudiantes',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel)

fig.show()

"""Se observa que la mayoría se encuentran en la categoría 2 y se espera ver una relación interesante con la variable respuesta.

15. *Faltas*
"""

df_sum = CALCULO.groupby('faltas')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df_sum, x='faltas', y='count', title='<b>Faltas a clase<b>')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Faltas',
    yaxis_title='Cantidad',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel2)
fig.show()

"""La mayoría se encuentra en la categoría 0, es decir que no faltaron a clase, en el análisis bivariado se verá más detalladamente esta variable. Se decide hacer una agrupación de las personas que no faltaron a clase, es decir, la clase 0 y por otra parte, las personas que si faltaron que se encuentran en las otras clases. esto con el fin de verificar cual de estas variables es significativa en el modelo."""

# Crear una nueva columna 'grupo' en CALCULO que tenga 0 si 'faltas' es igual a 0, y 1 en caso contrario.
CALCULO_nuevo['faltas_agrup'] = CALCULO_nuevo['faltas'].apply(lambda x: 0 if x == 0 else 1)

# Calcular la suma de 'count' por grupo.
df_sum = CALCULO_nuevo.groupby('faltas_agrup')['count'].sum().reset_index()

# Crear gráfica de barras.
fig = px.bar(df_sum, x='faltas_agrup', y='count', title='<b>Faltas a clase<b>')

# Renombrar etiquetas de los grupos en el eje x.
fig.update_xaxes(
    tickvals=[0, 1],
    ticktext=['0', '1'],
    title_text='Faltas'
)

# Agregar detalles a la gráfica.
fig.update_yaxes(title_text='Cantidad')
fig.update_layout(
    template='simple_white',
    title_x=0.5
)

# Cambiar los colores de las barras.
fig.update_traces(marker_color=px.colors.qualitative.Pastel2)
fig.show()

"""En esta gráfica se observa que los de la categoría 0 no faltaron a clase y los de la categoría 1 si lo hicieron.

16. *Soporte educativo extra*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'soporte_edu_extra', title = '<b>¿Tiene el estudiante soporte educatico extra?<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))


fig.show()

"""La variable soporte educativo extra se ve más cargada hacia la categoría "no", esto podría afectar el modelo, pero se considerará más adelante la posibilidad de eliminar esta variable.

17. *Soporte educativo familiar*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'soporte_edu_fam', title = '<b>¿Tiene el estudiante soporte educativo familiar?<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel1))

fig.show()

"""La variable parece tener sus categorías balanceadas, aunque igual será analizada más a fondo.

18. *Monitores*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'monitores', title = '<b>¿Tiene el estudiante clases extras pagadas por tutores privados?<b>')

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""La variable parece tener sus categorías balanceadas, aunque igual será observada más adelante en el análisis bivariado.

19. *Actividades extras*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'actividades_extra', title = '<b>¿Tiene el estudiante actividades extraescolares?<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)

# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""La variable parece estar balanceada, más adelante en el análisis bivariado será observada con mayor detalle.

20. *Preuniversitario*
"""

df_sum = CALCULO.groupby('preuniversitario')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df_sum, x='preuniversitario', y='count', title='<b>¿El estudiante asistio al preuniversitario?<b>')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Preuniversitario',
    yaxis_title='Cantidad',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel2)
fig.show()

"""Se observa que la categoría "si" tiene un mayor peso, esta variable se analizará con detalle más adelante para tomar una decisión con respecto a su pertinencia dentro del modelo.

21. *Postgrado*
"""

# hacer la gráfica
fig = px.pie(CALCULO, names = 'postgrado', title = '<b>¿El estudiante quiere hacer postgrado?<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)
# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel2))

fig.show()

"""En esta variable se nota que las categoría están desbalanceadas, con un 95% contra un 5%, esto no sería significativo para el modelo ya que sería como agregarle una constante, pero igual se va a ver en el análisis bivariado y se tomará una decisión más adelante.

22. *Internet*
"""

# Cambiar el nombre de las categorias a español
CALCULO['internet'] = CALCULO['internet'].replace('yes', 'si')

# hacer la gráfica
fig = px.pie(CALCULO, names = 'internet', title = '<b>¿El estudiante tiene acceso a Internet en casa?<b>')

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)
# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel1))

fig.show()

"""La categoría "si" se ve un poco cargada ya que contiene casi el 83% del total de estudiantes, igualmente se analizará esta variable más adelante.

23. *Relacion sentimental*
"""

# Cambiar el nombre de las categorias a español
CALCULO['relacion_sen'] = CALCULO['relacion_sen'].replace('yes', 'si')

# hacer la gráfica
fig = px.pie(CALCULO, names = 'relacion_sen', title = '<b>¿El estudiante tiene relación sentimental?<b>', hole = .5)

# poner detalles a la gráfica
fig.update_layout(
    template = 'simple_white',
    title_x = 0.5
)
# Personaliza los colores de los segmentos
fig.update_traces(marker=dict(colors=px.colors.qualitative.Pastel))

fig.show()

"""El 66.8% de los estudiantes tienen una relación sentimental, las categorían no parecen estar desbalanceadas, más adelante se analizará su relación con la variable independiente y se considerará su importancia dentro del modelo.

24. *Relación familiar*
"""

df = CALCULO.groupby('relacion_fam')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='count', y='relacion_fam', title='<b>Calidad de la relación familiar<b>', orientation='h')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Cantidad',
    yaxis_title='Niveles de satisfacción',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel2)

fig.show()

"""En esta variable se observa que la mayoría califican en 4 la relación con su familia y vemos que muy pocos tienen puntajes entre 1 y 2. Se decide agrupar las categorías 1 y 2, la 3 se dejará igual y agrupar la 4 con la 5, con esta nueva clasificación se espera ver más facil los que consideran tener una mala relación, una regular y una buena.

"""

CALCULO_nuevo['relacion_fam_agrup'] = CALCULO['relacion_fam']
CALCULO_nuevo['relacion_fam_agrup'] = CALCULO_nuevo['relacion_fam_agrup'].apply(lambda x: x + 1 if x in [1, 4] else x)
CALCULO_nuevo['relacion_fam_agrup'] = CALCULO_nuevo['relacion_fam_agrup'].replace({2: 1, 3: 2, 5: 3})

df = CALCULO_nuevo.groupby('relacion_fam_agrup')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='count', y='relacion_fam_agrup', title='<b>Calidad de la relación familiar<b>', orientation='h')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Cantidad',
    yaxis_title='Niveles de satisfacción',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel2)

fig.show()

"""Con est agrupación se ven mejor balanceadas las categorías

25. *Tiempo libre*
"""

df = CALCULO.groupby('tiempo_libre')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='count', y='tiempo_libre', title='<b>Tiempo libre después de la universidad<b>', orientation='h')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Cantidad',
    yaxis_title='Niveles de libertad de tiempo',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel2)

fig.show()

"""Considerando 1 como poco tiempo libre y 5 como mucho, 3 sería un punto intermedio, se observa que la mayoría de estudiantes se encuentran en esta categoría, en el análisis bivariado se verá si tiene relación con la variable independiente.

26. *Salir amigos*
"""

df = CALCULO.groupby('salir_amigos')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='salir_amigos', y='count', title='<b>Salir con amigos<b>')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Niveles',
    yaxis_title='Cantidad',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel)

fig.show()

"""La mayoría de estudiantes se encuentran en la categoría 3, se observa una buena distribución entre las demás categorías.

27. *Consumo alcohol semanal*
"""

df = CALCULO.groupby('cons_alcohol_sem')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='count', y='cons_alcohol_sem', title='<b>Consumo de alcohol en semana<b>', orientation='h')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Cantidad',
    yaxis_title='Niveles',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel1)

fig.show()

"""Se ve muy cargada en las categorías 1 y 2 por lo que se considera no incluirla en el modelo, pero aún así se va a evaluar su comportamiento en el análisis bivariado

28. *Consumo alcohol fines de semana*
"""

df = CALCULO.groupby('cons_alcohol_finde')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='cons_alcohol_finde', y='count', title='<b>Consumo de alcohol en fin de semana<b>')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Niveles',
    yaxis_title='Cantidad',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel)

fig.show()

"""La variable consumo de alcohol en semana tiene un comportamiento similar al consumo de alcohol en fin de semana, teniendo como mayoría la categoría 1.

29. *Salud*
"""

df = CALCULO.groupby('salud')['count'].sum().reset_index()

# Crear gráfica de barras
fig = px.bar(df, x='count', y='salud', title='<b>Estado de salud actual<b>', orientation='h')

# Agregar detalles a la gráfica
fig.update_layout(
    xaxis_title='Cantidad',
    yaxis_title='Niveles',
    template='simple_white',
    title_x=0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel1)

fig.show()

"""Se observa que la mayoría de estudiantes se encuentran en la categoría 5, es decir que cuentan con buena salud, se analizará más adelante cómo el nivel de salud puede afectar a la nota 3 que es nuestra variable respuesta.

30. *Ausencias*
"""

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO['ausencias'], name='Histograma de las ausencias', marker_color='turquoise'),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO['ausencias'], name='Boxplot de las ausencias', marker_color='lightgreen'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de las ausencias a la universidad",
    template='simple_white')
fig.show()

"""En esta variable se nota la presencia de muchos datos atípicos y un sesgo a la izquierda.

**Tratamiento de datos atipicos**
"""

# Función para identificar los datos atípicos
def percentiles(CALCULO, lim_inf, lim_sup):
  lim_inf = lim_inf
  lim_sup = lim_sup
  outliers = CALCULO[(CALCULO < CALCULO.quantile(lim_inf)) |(CALCULO > CALCULO.quantile(lim_sup))]
  return outliers

#Buscamos los datos atípicos por debajo y por encima. Los convertimos en una lista
ausencias_outlier_index = percentiles(CALCULO['ausencias'], 0.01, 0.99).index.tolist()
ausencias_outlier_values = percentiles(CALCULO['ausencias'], 0.01, 0.99).values.tolist()
print('Posición:', ausencias_outlier_index)
print('Valor:', ausencias_outlier_values)
print('Número de atipicos en ausencias a la universidad: ', len(ausencias_outlier_index))

"""La variable *ausencia* tiene 4 atípicos, los cuales representa un 1% de los datos. De acuerdo con esto, sabemos que un 1% de datos atípicos es una cifra poco significativa y que no afectaría drásticamente al modelo. Sin embargo, por cuestiones de limpieza de los datos consideramos que estos registros sean eliminados."""

# Eliminar atipicos
CALCULO = CALCULO.drop([74, 183, 276, 315])

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO['ausencias'], name='Histograma de las ausencias', marker_color='lightgreen'),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO['ausencias'], name='Boxplot de las ausencias', marker_color='turquoise'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de las ausencias a la universidad",
    template='simple_white')
fig.show()

"""se nota que mejoró la variable en cuanto a los atipicos

31. *Nota 1*
"""

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO['nota_01'], name='Histograma de la nota 1', marker_color='orange'),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO['nota_01'], name='Boxplot de la nota 1', marker_color='coral'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de la nota 1",
    template='simple_white')
fig.show()

"""Para esta variable se nota un comportamiento normal, sin presencia de atípicos.

32. *Nota 2*
"""

fig = make_subplots(rows=1, cols=2)

fig.add_trace(
    go.Histogram(x=CALCULO['nota_02'], name='Histograma de la nota 2', marker_color='lightblue'),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=CALCULO['nota_02'], name='Boxplot de la nota 2', marker_color='lightgreen'),
    row=1, col=2
)

fig.update_layout(
    title_text="Distribución de la nota 2",
    template='simple_white')
fig.show()

"""Para esta variable se nota un comportamiento normal, con presencia de pocos atípicos

## Analisis bivariado
"""

CALCULO.columns

"""Departamento vs Nota 3"""

# crear dataset
base = CALCULO.groupby(['departamento'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='departamento', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 segun la carrera<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'departamento',
    yaxis_title = 'nota_3',
    template = 'simple_white',
    title_x = 0.5)

#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel1)

fig.show()

"""No se observa una relación significativa entre estas variables, porque independiente del departamento al que pertenezca el estudiante el promedio de la nota no varía mucho. Por lo tanto esta variable no será considerada en el modelo.

Nota 3 vs Sexo
"""

fig = px.box(CALCULO,
             x='sexo',
             y='nota_03',
             color='sexo')

fig.update_layout(
    title_text='Distribución de la nota 3 según el sexo de los estudiantes',
    xaxis=dict(
        title='Sexo de los alumnos',
        titlefont_size=16
    ),
    yaxis=dict(
        title='Promedio nota 3',
        titlefont_size=16
    ),
    template='simple_white'
)
fig.show()

"""No se observa una relación significativa entre las categorias y la variable respuesta. Por lo tanto, no será considerada dentro del modelo.

Nota 3 vs Edad
"""

# crear base
base = CALCULO.groupby(['edad'])[['nota_03']].mean().reset_index().sort_values('edad', ascending = False)

# definir gráfica
fig = px.scatter(base, x='edad', y='nota_03',color_discrete_sequence=['green'])

# definir gráfica
fig.update_layout(
    title ='<b>Promedio Nota 3 según la edad<b>',
    xaxis_title = 'Edad',
    yaxis_title = 'Promedio nota 3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""En este gráfico se puede observar que hay una tendencia que a mayor edad menor nota. Por lo tanto, consideraremos esta variable en el modelo

Dirección vs Nota 3
"""

# crear dataset
base = CALCULO.groupby(['direccion'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='direccion', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 según su dirección<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Dirección',
    yaxis_title = 'Nota_3',
    template = 'simple_white',
    title_x = 0.5)
#cambiar los colores
fig.update_traces(marker_color=px.colors.qualitative.Pastel)

fig.show()

"""No se observa una relación significativa entre estas variables, porque independiente de la dirección donde vive el estudiante el promedio de la nota no varía mucho. Por lo tanto esta variable no será considerada en el modelo.

Nota 3 vs tamaño de la familia

*   'menor_e3' - menor o igual a 3
*   'mayor_3' - más de 3
"""

# crear dataset
base = CALCULO.groupby(['t_familia'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='t_familia', y='nota_03', barmode ='group', title ='<b>promedio Nota 3 segun el tamaño de la familia<b>')

# cambiar el color
fig.update_traces(marker_color='lightgreen')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 't_familia',
    yaxis_title = 'nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""No se observa una relación significativa entre estas variables, porque independiente del tamaño de la familia del estudiante el promedio de la nota no varía mucho. Por lo tanto esta variable no será considerada en el modelo.

Nota 3 vs Estado de convivencia de los padres

*   'J' - viven juntos
*   'S' - separados
"""

fig = make_subplots(rows=1, cols=2)

nota_por_status = CALCULO.groupby('padres_status')['nota_03'].mean().sort_values(ascending=True)
status_juntos = CALCULO.loc[CALCULO['padres_status']=='J']
status_separados = CALCULO.loc[CALCULO['padres_status']=='S']


colors=['lightsalmon', 'lightpink']

fig.add_trace(
    go.Bar(
        x=['J', 'S'],
        y=nota_por_status .values,
        name='Bar Chart',
        marker_color=colors,
        text=np.round(nota_por_status.values)),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=status_juntos['nota_03'], name='J', marker_color='lightsalmon'),
    row=1, col=2
)

fig.add_trace(
    go.Box(y=status_separados['nota_03'], name='S', marker_color='lightpink'),
    row=1, col=2
)

fig.update_layout(title_text="Promedio Nota 3 según el status de los padres", template='simple_white')
fig.show()

"""Teniendo en cuenta que en el análisis univariado hay muy poca variación entre categorías y que en este análisis bivariado no parece tener una relación con la variable respuesta se decide no tener en cuenta esta variable en el modelo.

Nota 3 vs nivel de educación de los padres
"""

# Crear subplots con dos columnas, una fila
fig = sp.make_subplots(rows=1, cols=2, shared_yaxes=True, horizontal_spacing=0.1)

# crear dataset para el primer gráfico
base1 = CALCULO.groupby(['madre_edu'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear el primer gráfico de barras
bar_chart1 = go.Bar(
    x=base1['madre_edu'],
    y=base1['nota_03'],
    marker_color='#88EE88',  # Color verde claro
    name='Nota 3'
)

# Agregar el gráfico a la primera columna
fig.add_trace(bar_chart1, row=1, col=1)

fig.update_xaxes(title_text="Nivel de Educación de la Madre", row=1, col=1)
fig.update_yaxes(title_text="Promedio Nota 3", row=1, col=1)
fig.update_layout(title_text='<b>Promedio Nota 3 según el Nivel de Educación de los padres<b>', title_x=0.5)

# crear dataset para el segundo gráfico
base2 = CALCULO.groupby(['padre_edu'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear el segundo gráfico de barras
bar_chart2 = go.Bar(
    x=base2['padre_edu'],
    y=base2['nota_03'],
    marker_color='#BB88FF',
    name='Nota 3'
)

# Agregar el segundo gráfico a la segunda columna
fig.add_trace(bar_chart2, row=1, col=2)

# Definir detalles y título para el segundo gráfico
fig.update_xaxes(title_text="Nivel de Educación del Padre", row=1, col=2)
fig.update_layout(title_text='<b>Promedio Nota 3 según el Nivel de Educación de los padres<b>', title_x=0.5)

# Mostrar la figura con los dos gráficos uno al lado del otro
fig.show()

"""Se nota una relación directamente proporcional donde se observa que a mayor educación de los padres, mejor resultado en la nota del estudiante.

Nota 3 vs trabajo de los padres
"""

# Crear subplots con dos columnas, una fila
fig = sp.make_subplots(rows=1, cols=2, shared_yaxes=True, horizontal_spacing=0.1)

# crear dataset para el primer gráfico
base1 = CALCULO.groupby(['madre_trab'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear el primer gráfico de barras
bar_chart1 = go.Bar(
    x=base1['madre_trab'],
    y=base1['nota_03'],
    marker_color='yellowgreen',
    name='Nota 3'
)

# Agregar el gráfico a la primera columna
fig.add_trace(bar_chart1, row=1, col=1)

fig.update_xaxes(title_text="Trabajo de la Madre", row=1, col=1)
fig.update_yaxes(title_text="Promedio Nota 3", row=1, col=1)
fig.update_layout(title_text='<b>Promedio Nota 3 según el trabajo de los padres<b>', title_x=0.5)

# crear dataset para el segundo gráfico
base2 = CALCULO.groupby(['padre_trab'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear el segundo gráfico de barras
bar_chart2 = go.Bar(
    x=base2['padre_trab'],
    y=base2['nota_03'],
    marker_color='lightsteelblue',
    name='Nota 3'
)

# Agregar el segundo gráfico a la segunda columna
fig.add_trace(bar_chart2, row=1, col=2)

# Definir detalles y título para el segundo gráfico
fig.update_xaxes(title_text="Trabajo del padre", row=1, col=2)
fig.update_layout(title_text='<b>Promedio Nota 3 según el trabajo de los padres<b>', title_x=0.5)

# Mostrar la figura con los dos gráficos uno al lado del otro
fig.show()

"""El promedio de la nota 3 no cambia mucho dependiendo del trabajo de los padres, consideramos que no va a aportar información importante al modelo, por lo que decide no incluirla en el modelo

Nota 3 vs Razón de elegir la carrera
"""

fig = make_subplots(rows=1, cols=2)

nota_por_razon = CALCULO.groupby('razon')['nota_03'].mean().sort_values(ascending=True)
razon_recomendacion = CALCULO.loc[CALCULO['razon']=='recomendacion']
razon_reputacion = CALCULO.loc[CALCULO['razon']=='reputacion']
razon_habilidad = CALCULO.loc[CALCULO['razon']=='habilidad']
razon_otro = CALCULO.loc[CALCULO['razon']=='otro']

colors = ['#88EE88', '#66BBCC', '#4477AA', '#AA88EE']

fig.add_trace(
    go.Bar(
        x=['recomendacion', 'reputación', 'habilidad', 'otro'],
        y=nota_por_razon .values,
        name='Bar Chart',
        marker_color=colors,
        text=np.round(nota_por_razon.values)),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=razon_recomendacion['nota_03'], name='recomendacion', marker_color='#88EE88'),
    row=1, col=2
)

fig.add_trace(
    go.Box(y=razon_reputacion['nota_03'], name='reputación', marker_color='#66BBCC'),
    row=1, col=2
)

fig.add_trace(
    go.Box(y=razon_habilidad['nota_03'], name='habilidad', marker_color='#4477AA'),
    row=1, col=2
)

fig.add_trace(
    go.Box(y=razon_otro['nota_03'], name='otro', marker_color='#AA88EE'),
    row=1, col=2
)

fig.update_layout(title_text="Promedio Nota 3 según la razón de elegir la carrera", template='simple_white')
fig.show()

"""La razón por la cual se escogio la carrera no parece afectar mucho los resultados en la nota 3, por lo que se decide qu eno va a aportar infomación importante en el modelo y no será incluida en este.

Nota 3 vs guardian o tutor del estudiante
"""

# crear dataset
base = CALCULO.groupby(['guardian'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='guardian', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 segun el tutor del estudiante<b>')

# cambiar el color
fig.update_traces(marker_color='lightblue')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'guardian',
    yaxis_title = 'nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""El tutor o guardian del estudiante no afecta la nota 3 del estudiante, se decide no incluirla en el modelo.

Nota 3 vs tiempo que tardo en realizar el examen

*   1 - <15 min.
*   2 - 15 a 30 min.
*   3 - 30 min. a 1 hora
*   4 - >1 hora
"""

# Crear el dataset base
base = CALCULO.groupby(['t_examen'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear la gráfica de barras
bar_fig = px.bar(base, x='t_examen', y='nota_03', barmode='group', title='<b>Promedio Nota 3 segun el tiempo de examen<b>')
bar_fig.update_traces(marker_color='#66BBCC')


# Crear la base para la gráfica de dispersión
base_line = CALCULO.groupby(['t_examen'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=False)

# Crear la gráfica de dispersión
line_fig = px.scatter(base_line, x='t_examen', y='nota_03')

# Crear subplots
fig = make_subplots(rows=1, cols=2, subplot_titles=('Promedio Nota 3 segun el tiempo del examen', ' '))

# Agregar la gráfica de barras al primer subplot
for trace in bar_fig.data:
    fig.add_trace(trace, row=1, col=1)

# Agregar la gráfica de líneas al segundo subplot
for trace in line_fig.data:
    fig.add_trace(trace, row=1, col=2)

fig.update_layout(
    title_text='<b>Promedio Nota 3 segun el tiempo que tardó en realizar el examen<b>',
    xaxis_title='Tiempo en examen',
    yaxis_title='Promedio nota 3',
    template='simple_white',
    title_x=0.5)

# Mostrar la figura con ambos subplots
fig.show()

"""Considerando que la categoría 1 equivale a menos de 15 minutos realizando el examen, hallamos un poco ilógico que sean los que obtienen notas más altas respecto a los que tardaron más tiempo, ya que por experiencia propia sabemos que un examen de cálculo no se resuelve en 15 minutos. Por esta incoherencia consideramos no incluir la variable en el modelo para que no se vea afectada.

Nota 3 vs tiempo de estudio
Tiempo de estudio semanal

*   1 - <2 horas
*   2 - 2 a 5 horas
*   3 - 5 a 10 horas
*   4 - >10 horas
"""

# crear base
base = CALCULO.groupby(['t_estudio'])[['nota_03']].mean().reset_index().sort_values('t_estudio', ascending = False)

# definir gráfica
fig = px.scatter(base, x='t_estudio', y='nota_03')

# definir gráfica
fig.update_layout(
    title ='<b>Promedio Nota 3 según el tiempo de estudio<b>',
    xaxis_title = 'Tiempo de estudio',
    yaxis_title = 'Promedio nota 3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Se observa una relación directamente proporcional del tiempo de estudio y la nota obtenida, a mayor tiempo de estudio mayor nota.

Nota 3 vs faltas a clase

*   n si 1<=n<3
*   si no 4
"""

# crear dataset
base = CALCULO.groupby(['faltas'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='faltas', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 según las faltas a clase<b>')

# cambiar el color
fig.update_traces(marker_color='lightpink')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'faltas',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Se observa una relación inversamente proporcional entre estas variables y tiene bastante sentido que a más faltas del estudiante obtenga una menor nota.

Nota 3 vs apoyo educativo adicional
"""

# crear dataset
base = CALCULO.groupby(['soporte_edu_extra'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='soporte_edu_extra', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 según el apoyo educativo adicional<b>')

# cambiar el color
fig.update_traces(marker_color='#88EE88')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Apoyo educativo adicional',
    yaxis_title = 'Promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""No se nota una relación directa entre estas variables ya que la nota no varía mucho en las categorías, además no tiene mucho sentido que al recibir apoyo educativo se obtenga menor nota que los que no lo tuvieron, se decide no incluir esta variable en el modelo.

Nota 3 vs apoyo educativo familiar
"""

# crear dataset
base = CALCULO.groupby(['soporte_edu_fam'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='soporte_edu_fam', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 según el apoyo educativo familiar<b>')

# cambiar el color
fig.update_traces(marker_color='#BB66BB')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Apoyo educativo familiar',
    yaxis_title = 'Promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""No se nota una relación directa entre estas variables ya que la nota no varía dependiendo del apoyo educativo familiar, además los que tienen apoyo educativo familiar deberían obtener mejores notas y no sucede así, se decide no incluir esta variable en el modelo.

Nota 3 vs monitores
"""

# crear dataset
base = CALCULO.groupby(['monitores'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='monitores', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 vs tener tutores privados<b>')

# cambiar el color
fig.update_traces(marker_color='#FF8888')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'tener tutores privados',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""No se nota una relación directa entre estas variables ya que la nota no varía mucho dependiendo de si el estudiante tuvo o no un tutor privado, se decide no incluir esta variable en el modelo.

Nota 3 vs actividades extrescolares
"""

# crear dataset
base = CALCULO.groupby(['actividades_extra'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='actividades_extra', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 segun las actividades extra<b>')

# cambiar el color
fig.update_traces(marker_color='#FFAA66')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'actividades extra',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Las actividades extra no parecen influir en la nota 3, por eso no serán incluidas dentro del modelo.

Nota 3 vs preuniversitario
"""

# crear dataset
base = CALCULO.groupby(['preuniversitario'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='preuniversitario', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 vs preuniversitario<b>')

# cambiar el color
fig.update_traces(marker_color='#CCCCCC')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'preuniversitario',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Consideramos que no hay una relación significativa entre las variables ya que no cambia mucho la nota de una categoría a otra.

Nota 3 vs quiere hacer postgrado
"""

# crear dataset
base = CALCULO.groupby(['postgrado'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='postgrado', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 vs desea hacer postgrado<b>')

# cambiar el color
fig.update_traces(marker_color='#66CCCC')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'postgrado',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Complementando el análisis univariado con el bivariado, tomamos la decision de descartar esta variable ya que como lo dijimos anteriormente los datos estan muy cargado hacia la categoría sí.

Nota 3 vs acceso a internet
"""

fig = make_subplots(rows=1, cols=2)

nota_internet = CALCULO.groupby('internet')['nota_03'].mean().sort_values(ascending=True)
internet_si = CALCULO.loc[CALCULO['internet']=='si']
internet_no = CALCULO.loc[CALCULO['internet']=='no']

colors = ['#88EE88', '#66BBCC']

fig.add_trace(
    go.Bar(
        x=['si', 'no'],
        y=nota_internet.values,
        name='Bar Chart',
        marker_color=colors,
        text=np.round(nota_internet.values)),
    row=1, col=1
)

fig.add_trace(
    go.Box(y=internet_si['nota_03'], name='si', marker_color='#88EE88'),
    row=1, col=2
)

fig.add_trace(
    go.Box(y=internet_no['nota_03'], name='no', marker_color='#66BBCC'),
    row=1, col=2
)


fig.update_layout(title_text="Promedio Nota 3 segun el acceso a internet", template='simple_white')
fig.show()

"""Se puede observar que el tener internet disminuye la dispersión de los datos, por lo que se decide considerar esta variable en el modelo ya que puede ser interesante analizar esta relación más adelante.

Nota 3 vs relacion sentimental
"""

# crear dataset
base = CALCULO.groupby(['relacion_sen'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='relacion_sen', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 vs relacion sentimental<b>')

# cambiar el color
fig.update_traces(marker_color='#FF8888')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'relacion sentimental',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""La diferencia de la nota 3 en ambas categorías no tiene mucha diferencia, aunque consideramos que tener una relación sentimental si puede influir en la nota ya que se invierte más tiempo en esa persona y menos en el estudio, por lo que consideramos analizarla en el modelo.

Nota 3 vs calidad de relaciones familiares

de 1 - muy mala a 5 - excelente
"""

# Crear la base de datos para la primera gráfica
base1 = CALCULO.groupby(['relacion_fam'])[['nota_03']].mean().reset_index().sort_values('relacion_fam', ascending=False)

# Crear la base de datos para la segunda gráfica
base2 = CALCULO.groupby(['relacion_fam'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear la primera gráfica de dispersión
fig1 = go.Figure()
fig1.add_trace(go.Scatter(x=base1['relacion_fam'], y=base1['nota_03'], mode='markers', name='Promedio Nota 3'))
fig1.update_layout(
    title='<b>Promedio Nota 3 según la calidad de relaciones familiares<b>',
    xaxis_title='Calidad relaciones familiares',
    yaxis_title='Promedio nota 3',
    template='simple_white',
    title_x=0.5
)

# Crear la segunda gráfica de barras
fig2 = go.Figure()
fig2.add_trace(go.Bar(x=base2['relacion_fam'], y=base2['nota_03'], name='Promedio Nota 3', marker_color='#FF8888'))
fig2.update_layout(
    title='<b>Promedio Nota 3 vs relación familiar<b>',
    xaxis_title='Relación familiar',
    yaxis_title='Promedio nota 3',
    template='simple_white',
    title_x=0.5
)

# Crear la figura con dos subplots uno al lado del otro
fig = make_subplots(rows=1, cols=2, subplot_titles=("Nota 3 vs relacion familiar", " "))
fig.add_trace(fig1.data[0], row=1, col=1)
fig.add_trace(fig2.data[0], row=1, col=2)

# Actualizar el diseño de la figura global
fig.update_layout(showlegend=True,
                  xaxis_title='Relación familiar',
                  yaxis_title='Promedio nota 3')

# Mostrar la figura
fig.show()

"""aunque la categoría 3 está más cargada que las demás no se nota un cambio significativo en la nota, por lo que se decide no tener en cuenta esta variable en el modelo

Nota 3 vs tiempo libre
"""

# Crear la base de datos para la primera gráfica
base1 = CALCULO.groupby(['tiempo_libre'])[['nota_03']].mean().reset_index().sort_values('tiempo_libre', ascending=False)

# Crear la base de datos para la segunda gráfica
base2 = CALCULO.groupby(['tiempo_libre'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear la primera gráfica de dispersión
fig1 = go.Figure()
fig1.add_trace(go.Scatter(x=base1['tiempo_libre'], y=base1['nota_03'], mode='markers', name='Promedio Nota 3'))
fig1.update_layout(
    template='simple_white',
    title_x=0.5)

# Crear la segunda gráfica de barras
fig2 = go.Figure()
fig2.add_trace(go.Bar(x=base2['tiempo_libre'], y=base2['nota_03'], name='Promedio Nota 3', marker_color='#88EE88'))
fig2.update_layout(
    template='simple_white',
    title_x=0.5)

# Crear la figura con dos subplots uno al lado del otro
fig = make_subplots(rows=1, cols=2, subplot_titles=("Nota 3 segun el tiempo libre", " "))
fig.add_trace(fig1.data[0], row=1, col=1)
fig.add_trace(fig2.data[0], row=1, col=2)

# Actualizar el diseño de la figura global
fig.update_layout(showlegend=True,
                  xaxis_title='Tiempo libre',
                  yaxis_title='Promedio nota 3')

# Mostrar la figura
fig.show()

"""Consideramos que el tiempo libre es una variable muy relativa y dificil de analizar ya que depende mucho de cómo se invierta ese tiempo y como se reparta, aún así decidimos considerar esta variable en el modelo para ver como afecta ésta en su comportamiento

Nota 3 vs salir con amigos

desde 1 - muy baja hasta 5 - muy alta
"""

# Crear la base de datos para la primera gráfica
base1 = CALCULO.groupby(['salir_amigos'])[['nota_03']].mean().reset_index().sort_values('salir_amigos', ascending=False)

# Crear la base de datos para la segunda gráfica
base2 = CALCULO.groupby(['salir_amigos'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear la primera gráfica de dispersión
fig1 = go.Figure()
fig1.add_trace(go.Scatter(x=base1['salir_amigos'], y=base1['nota_03'], mode='markers', name='Promedio Nota 3'))

# Crear la segunda gráfica de barras
fig2 = go.Figure()
fig2.add_trace(go.Bar(x=base2['salir_amigos'], y=base2['nota_03'], name='Promedio Nota 3', marker_color='#AA88EE'))

# Crear la figura con dos subplots uno al lado del otro
fig = make_subplots(rows=1, cols=2, subplot_titles=("Nota 3 vs salir con amigos", " "))
fig.add_trace(fig1.data[0], row=1, col=1)
fig.add_trace(fig2.data[0], row=1, col=2)

# Actualizar el diseño de la figura global
fig.update_layout(showlegend=True,
                  xaxis_title='salir con amigos',
                  yaxis_title='Promedio nota 3')

# Mostrar la figura
fig.show()

"""Se nota una relación entre estas variables ya que el 5 que significa que salen mucho con los amigos tienen menores notas, esto tiene sentido ya que se dedica menos tiempo al estudio, sin embargo para la categoría 1 que indica que salen muy poco con los amigos no aumenta tanto la nota como se esperaría pero puede deberse a que este tiempo no sea empleado en estudiar, se decide considerar esta variable para ver como se comporta en el modelo.

Nota 3 vs consumo alcohol

de 1 - muy bajo a 5 - muy alto
"""

# Crear la base de datos para la primera gráfica
base1 = CALCULO.groupby(['cons_alcohol_sem'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear la base de datos para la segunda gráfica
base2 = CALCULO.groupby(['cons_alcohol_finde'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending=True)

# Crear la primera gráfica de línea
fig1 = go.Figure()
fig1.add_trace(go.Bar(x=base1['cons_alcohol_sem'], y=base1['nota_03'], name='Promedio Nota 3'))

# Crear la segunda gráfica de barras
fig2 = go.Figure()
fig2.add_trace(go.Bar(x=base2['cons_alcohol_finde'], y=base2['nota_03'], name='Promedio Nota 3', marker_color='#FFAA66'))

# Crear la figura con dos subplots uno al lado del otro
fig = make_subplots(rows=1, cols=2, subplot_titles=("Nota 3 vs consumo alcohol en semana", "Nota 3 vs consumo alcohol finde"))
fig.add_trace(fig1.data[0], row=1, col=1)
fig.add_trace(fig2.data[0], row=1, col=2)

# Actualizar el diseño de la figura global
fig.update_layout(showlegend=True,
                  xaxis_title='consumo alcohol',
                  yaxis_title='Promedio nota 3')

# Mostrar la figura
fig.show()

"""Notamos un  comportamiento muy similar entre ambas variables y puede ser interesante su comportamiento en el modelo, se decide incluirlas en este.

Nota 3 vs salud
"""

# crear dataset
base = CALCULO.groupby(['salud'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='salud', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 vs salud<b>')

# cambiar el color
fig.update_traces(marker_color='#CCCCCC')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'salud',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Se observa un comportamiento no esperado ya que las personas que tienen menos salud sacan notas más altas que las personas que gozan de mejor salud, consideramos que no tiene mucho sentido, además no existe mucha diferencia de la nota en las categorías.

Nota 3 vs ausencias

de 0 a 93
"""

# crear dataset
base = CALCULO.groupby(['ausencias'])[['nota_03']].mean().reset_index().sort_values('nota_03', ascending = True)

# crear gráfica
fig = px.bar(base, x='ausencias', y='nota_03', barmode ='group', title ='<b>Promedio Nota 3 vs ausencias<b>')

# cambiar el color
fig.update_traces(marker_color='#CCCCCC')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'ausencias',
    yaxis_title = 'promedio nota_3',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""Se observa gran variabilidad en los datos, se esperaría que a mayor cantidad de ausencias disminuyera la nota 3 pero realmente el cambio e smuy poco significativo por lo cual se decide que esta variable no será considerada en el modelo.

Nota 3 vs Nota 1 y Nota 2
"""

# Crear la base de datos para la primera gráfica
base = CALCULO.groupby(['nota_01'])[['nota_03']].mean().reset_index().sort_values('nota_01', ascending=False)

# Crear la base de datos para la segunda gráfica
base2 = CALCULO.groupby(['nota_02'])[['nota_03']].mean().reset_index().sort_values('nota_02', ascending=False)

# Crear las figuras con Plotly Express
fig1 = px.scatter(base, x='nota_01', y='nota_03')
fig2 = px.scatter(base2, x='nota_02', y='nota_03')

# Crear la figura con dos subplots uno al lado del otro
fig = make_subplots(rows=1, cols=2, subplot_titles=("Nota 3 vs Nota 1", "Nota 3 vs Nota 2"))
fig.add_trace(fig1.data[0], row=1, col=1)
fig.add_trace(fig2.data[0], row=1, col=2)

# Actualizar el diseño de la figura
fig.update_layout(
    title='<b>Promedio Nota 3 según la nota 1 y 2</b>',
    xaxis_title='Nota',
    yaxis_title='Promedio nota 3',
    template='simple_white',
    title_x=0.5)

fig.show()

"""A mayor resultado en los examenes 1 y 2, mayor la nota 3

## Analisis de correlación

###Para variables numéricas
"""

#Se crea una variable solo con las variables numericas
variables_numericas = CALCULO.select_dtypes(include=['number'])

# Calcula la matriz de correlación.
matriz_correlacion = variables_numericas.corr()

# Visualizar la matriz de correlación
plt.figure(figsize=(10, 8), dpi=80)
sns.heatmap(matriz_correlacion, annot=True, fmt=".2f", linewidths=0.5, linecolor='white')
plt.title("Mapa de calor")
plt.show()

"""Se han identificado tres correlaciones significativas, entre las que se destaca la similitud entre las variables de educación de la madre y del padre, lo que resalta la importancia de abordar la multicolinealidad en el análisis. Además, se ha observado la relación entre salir con amigos y el consumo de alcohol durante el fin de semana, lo que podría tener implicaciones importantes en el análisis. Asimismo, se ha señalado la correlación entre el consumo de alcohol en la jornada laboral y en los fines de semana, lo que podría ser crucial para comprender los patrones generales de consumo. En conjunto, esta evaluación demuestra un enfoque lógico y orientado hacia la acción, con la intención de profundizar en estas correlaciones en el modelo para obtener insights valiosos de los datos.

### Prueba Chi-Cuadrado entre variables categóricas
"""

# Filtra las columnas que son de tipo 'object' (categóricas).
categorical_columns = CALCULO.select_dtypes(include=['object'])

# Obtiene los nombres de las columnas categóricas en dos listas.
categoricas1 = categorical_columns.columns.tolist()
categoricas2 = categorical_columns.columns.tolist()

# crear las posibles combinaciones entre las dos tuplas
cat_var_prod = list(product(categoricas1,categoricas2, repeat = 1))

# crear una variable vacia para almacenar los datos y almacenar solo el valor-p del resultado
import scipy.stats as ss
result = []
for i in cat_var_prod:
  if i[0] != i[1]:
    result.append((i[0],i[1],list(ss.chi2_contingency(pd.crosstab(
                            categorical_columns[i[0]], categorical_columns[i[1]])))[1]))

# Organizar decimales
pd.options.display.float_format = '{:.5f}'.format

# Crear una tabla similar a la que usamos cuando calculamos la correlación
chi_test_output = pd.DataFrame(result, columns = ['var1', 'var2',
                                                       'coeff'])
# Usar la función pivot para convertir el dataframe en un crosstab
chi_test_output.pivot(index='var1', columns='var2', values='coeff')

"""Existe una relación entre dos variables si el valor de p ≤ 0,05. Este estadistico permite contrastar la hipotesis de independencia en una tabla de contingencia pero no nos dice la fuerza de la asociación"""

# @title **Matriz de Correlación**
corrmat = CALCULO.corr()
corrmat

"""Esto se observo de una manera eficiente en la matriz de correlación con el mapa de calor."""

# @title **Relaciones entre Variables**
sns.pairplot(CALCULO)
plt.show()

"""Las conclusiones de las correlaciones entre variables se dieron anteriormente con el mapa de calor.

## Selección de variables
"""

# Agregamos la columna reprobado para la nota 3, para volverla binaria
CALCULO['nota_3'] = CALCULO['nota_03'].apply(lambda x: 0 if x < 12 else 1)

y_target = CALCULO['nota_3']  #Variable objetivo que queremos predecir.
X_features = CALCULO.drop(['departamento', 'sexo', 'direccion', 't_familia',
       'padres_status', 'madre_trab', 'padre_trab', 'razon', 'guardian', 't_examen',
       'soporte_edu_extra', 'soporte_edu_fam', 'monitores', 'actividades_extra',
       'preuniversitario', 'postgrado', 'relacion_fam', 'salud', 'nota_03', 'count', 'nota_3'], axis=1, inplace=False)
#Quitamos las columnas que no se necesitan para el modelo y dejamos solamente las relevantes.

"""Dado el análisis de las variables se consideraron las variables anteriormente puestas en el código."""

X_features #Miremos como queda X_features con las variables que si nos interesan. Quedan 12 variables.

"""## Limpieza y transformación de los datos

### Convertir variables categoricas a numericas
"""

# Identificar las columnas categóricas
categorical_columns = X_features.select_dtypes(include=['object']).columns

# Iterar a través de las columnas categóricas y mostrar las categorías únicas
for column in categorical_columns:
    unique_categories = X_features[column].unique()
    print(f'Categorías en "{column}": {unique_categories}')

# Transformación de las variables categoricas binarias
# Crear un objeto LabelEncoder
le = LabelEncoder()

# Iterar a través de las columnas categóricas y aplicar LabelEncoder si hay 2 categorías
for column in categorical_columns:
    if len(X_features[column].unique()) == 2:  # Verificar si hay solo 2 categorías
       X_features[column] = le.fit_transform(X_features[column])

X_features

"""## Estandarización y escalado de variables

### Simple Feature Scaling
"""

# crear una copia del DataFrame
df_cal1 = X_features.copy()

# generar una función para todas las variables
for i in df_cal1.columns:
  df_cal1[i] = df_cal1[i]/df_cal1[i].max()

df_cal1

"""## Validar distribución variable respuesta"""

# crear dataset
base = CALCULO.groupby(['nota_3'])[['count']].count().reset_index().sort_values('count', ascending = False)

# crear gráfica
fig = px.bar(base, x='nota_3', y='count', width = 650, height = 500)

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Nota 3',
    yaxis_title = 'Cantidad',
    template = 'simple_white',
    title_x = 0.5)

fig.show()

"""## División Train/Test"""

x_train,x_test,y_train,y_test = train_test_split(X_features,y_target,shuffle = True,test_size=0.30, random_state=123)
# shuffle si aleatorizar los datos antes de partir en train y test

#X_train, X_test, y_train, y_test = train_test_split(X_features, y_target, test_size=0.3, random_state=42)
#Dividimos en un  los datos de train y test

"""##**Modelo**"""

!pip install -U imbalanced-learn

from imblearn.under_sampling import NearMiss
from imblearn.over_sampling import RandomOverSampler
from imblearn.combine import SMOTETomek
from imblearn.ensemble import BalancedBaggingClassifier
from sklearn.datasets import make_classification
from collections import Counter

# Entrenar modelo
model_01 = LogisticRegression(random_state=123,class_weight="balanced", max_iter=1000) # definir el modelo
model_01.fit(x_train,y_train) # entrenar el modelo
y_pred_test_01 = model_01.predict(x_test) # predecir

y_pred_test_01

"""Los valores en la variable y_pred_test_01 representan las predicciones del modelo de regresión logística en el conjunto de datos de prueba. Un valor de 1 indica que el modelo predice que el ejemplo pertenece a la clase positiva, mientras que un valor de 0 indica que predice la clase negativa.

##Metricas de desempeño
"""

# Matriz de confusión:
cm = confusion_matrix(y_test, y_pred_test_01, labels=model_01.classes_) # guardar las clases para la matriz de confusión
disp = ConfusionMatrixDisplay(confusion_matrix=cm,display_labels=model_01.classes_)
disp.plot();
print(cm)

TP=cm[0,0]
FP=cm[1,0]
FN=cm[0,1]
TN=cm[1,1]

print(f"Accuracy test: {accuracy_score(y_test, y_pred_test_01)}")
print(f'Precicion: {TP/(TP+FP)}')
print(f'Recuperacion (Sensibilidad)): {TP/(TP+FN)}')
print(f'F1-score:', f1_score(y_test, y_pred_test_01, average='weighted'))
print(f'Especificidad: {TN/(FP+TN)}')

from sklearn.metrics import roc_curve, auc, roc_auc_score
y_pred = model_01.predict_proba(x_test)[::,1]
fpr, tpr,_ =roc_curve(y_test, y_pred)
# auc=auc(fpr, tpr) #opción 1
auc = roc_auc_score(y_test, y_pred) #opción 2
plt.plot(fpr, tpr,marker='.',label='Logistic (auc= %0.3f)'%auc)
plt.xlabel('False positive rate')
plt.ylabel('True positive rate')
plt.legend()
plt.show()

from plot_metric.functions import BinaryClassification
# Visualisation with plot_metric
bc = BinaryClassification(y_test, y_pred, labels=["Class 1", "Class 2"])

# Figures
plt.figure(figsize=(5,5))
bc.plot_roc_curve()
plt.show()

"""## 2. Segunda Entrega - Aplicación de otros algoritmos de Machine Learning

Como resumen del primer trabajo podemos decir lo siguiente: <br>
*  Existe Una correlación positiva entre la educación de los padres (tanto madre como padre) y las notas académicas. Esto sugiere que los estudiantes cuyos padres tienen un nivel educativo más alto tienden a obtener mejores calificaciones.

*  Existe una correlación negativa entre las faltas y las notas académicas. Esto indica que los estudiantes con más faltas tienden a tener peores calificaciones.

*  Existe una correlación positiva entre el tiempo de estudio y las notas académicas. Los estudiantes que estudian más tiempo suelen obtener mejores calificaciones.

* Hallamos correlaciones positivas entre las variables de consumo de alcohol (tanto durante la semana como los fines de semana) y salir con amigos. Esto sugiere que los estudiantes que consumen alcohol tienden a salir más con amigos.

*  Encontramos una correlación negativa entre la salud y las notas académicas. Los estudiantes con una salud peor tienden a tener peores calificaciones.

### a. Selección y Aplicación de Algoritmos:

En esta etapa, seleccionaremos y aplicaremos algoritmos de aprendizaje supervisado para predecir la variable objetivo "nota_03". Dado que estamos abordando un problema de regresión (predecir un valor numérico), aquí hay algunos algoritmos que podrían ser adecuados:<br>

*   Regresión Lineal
*   Regresión Ridge
*   Regresión Lasso
*   Support Vector Regression (SVR)
*   Random Forest Regressor
*   Gradient Boosting Regressor

### b. Comparación con modelo desarrollado en la entrega 1
Compararemos el rendimiento del nuevo modelo con el modelo base. Se usará el error cuadrático medio, MAE o el coeficiente de determinación.

### c. Afinamiento de hiperparámetros
Grid search u optimización bayesiana

### d. Evaluación y análisis del mejor modelo
Métricas de desempeño en un conjunto de pruebas independiente.<br>
Gráficos de dispersión
"""
